module HelloWorld

type ClosureData class {
	
}

func test(i, j int) int {
	return i + j
}

func testPow(a, b float) float {
	return a ** b
}

func testPowI(a, b int) int {
	return (a ** b) as int
}

func main() double {
	let b = true
	
	let a1 = 2.0_f32
	let a2 = 3.0_f32
	let a3 = 5.0_f32
	
	if(a1 > a2){
		return a1 ** a2 // 8
	}else if(a2 > a3){
		return a1 ** a3 // 32
	}else{
		return a2 ** a3 // 243
	}
	
	a1 = testPow(a1, a2)
	// return a1

	let b1 = 5
	let b2 = 2
	b1 = testPowI(b1, b2)
	
	let jj = test(100000, 80000)
	
	// let ff func(i, j int)int = test
	let ff = test
	jj = ff(400000, 30000)

	type TestBytes class {
		a, b byte
		c int
	}
	
	type Test class {
		c TestBytes
		a, b int
	}
	
	/* impl Test {
		
		func GetA() int {
			return a
		}
		
		func mut SetA(a int) {
			@a = a
		}
		// func mut setA(a int){ @a = a; }
		
		static {
			
		}
	} */
	
	let mut t = Test{TestBytes{1, 2, 3}, 300, 600}
	t = Test{b: 700}
	// t.c.b = 10
	// t.c.c = t.GetA()
	// t.b = 500
	
	// t = Test{a=400, b=700}

	type a [10]byte
	let mut i = sizeof a[2]
	i = sizeof t
	i = sizeof Test
	i = sizeof t.c.c
	i = sizeof Test.a
	i = 10i8 + 8u16
	
	// let k
	let j = i + 2.5 + t.b
	
	let f = func(i float) ? {
		return i
	}
	
	func getArr() ? {
		let arr [6]int32
		arr[1] = 1000
		return arr
	}
	
	let arr [10][6]int32
	arr[5] = getArr()
	
	let arr2 = arr
	
	/*
	let j unsafe * mut int = unsafe & i
	let v & mut int = i
	v = 5
	&v = 8
	*/
	let k = 5
	return (arr2[k][1] + j + f(3) + jj) ** 0.5
}
